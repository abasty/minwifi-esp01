/*
 * Copyright Â© 2023 Alain Basty
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice (including the
 * next paragraph) shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


#include "ds_common.h"
#include "ds_btree.h"
#include "ds_lifo.h"
#include "bmemory.h"
#include "token.h"

ds_btree_t prog_tree;
ds_lifo_t prog_list;

bmem_t *bmem;

// total size in bytes of a var
// 1 float: sizeof(var_t) + sizeof(float) + (len(name) +  Len(name) % 4)
// 1 string: sizeof(var_t) + (len(string) + 1) + (len(name) +  Len(name) % 4)
// # floats: sizeof(var_t) + dim_count * 4 + P(dims) * 4 + (len(name) +  Len(name) % 4)
//     A(n = P(i0, i1, ...)): numbers[n + #dims]
// # strings: sizeof(var_t) + dim_count * 4 + P(dims) * 1 + (len(name) +  Len(name) % 4)
//     A$(n = P(i0, i1, ...)): bytes[n + #dims]

// P() = ((i0 - 1) * dims[1] + (i1 - 1)) * dims[2] + ...

static var_t *bmem_var_alloc(uint16_t size)
{
    int psize = bmem_align4(size);
    // printf("Allocating %d bytes\n", psize);
    if (bmem->vars_start - bmem->prog_end < psize)
        return 0;

    bmem->vars_start -= psize;
    memset(bmem->vars_start, 0, psize);
    return (var_t *)bmem->vars_start;
}

static int bmem_strlen(const char *str)
{
    if (!str)
        return 0;

    int n = 0;
    while (*str++)
    {
        n++;
    }
    return n;
}

static int bmem_array_size(int cell_size, uint8_t dim_count, uint32_t *dims)
{
    int size = cell_size;
    for (int i = 0; i < dim_count; i++)
    {
        size *= dims[i];
    }
    return size;
}

static int bmem_data_size(uint8_t token, uint8_t dim_count, uint32_t *dims)
{
    int size = 0;
    switch (token)
    {
    case TOKEN_VARIABLE_NUMBER:
        size = sizeof(float);
        break;
    case TOKEN_VARIABLE_STRING:
        size = dim_count + 1;
        break;
    case TOKEN_ARRAY_NUMBER:
        size = bmem_array_size(sizeof(float), dim_count, dims);
        break;
    case TOKEN_ARRAY_STRING:
        size = bmem_array_size(1, dim_count, dims);
        break;
    }
    return size;
}

static var_t *bmem_var_new(const char *name, uint8_t token, uint8_t dim_count, uint32_t *dims)
{
    int name_size = bmem_strlen(name) + 1;
    int data_size = bmem_data_size(token, dim_count, dims);
    int dims_size = dims ? dim_count * sizeof(uint32_t) : 0;

    // Allocate var
    var_t *var = bmem_var_alloc(sizeof(var_t) + dims_size + data_size + name_size);
    if (!var)
        return 0;

    // Init var
    var->token = token;
    var->name_ofs = data_size + dims_size;

    // Copy dims
    if (dims)
    {
        memcpy(var->dims, dims, dims_size);
        var->dim_count = dim_count;
    }
    else
    {
        var->dim_count = 0;
    }

    // Copy name
    memcpy(var->bytes + var->name_ofs, name, name_size);

    return var;
}

static int bmem_var_size(var_t *var)
{
    return bmem_align4(sizeof(var_t) + var->name_ofs + bmem_strlen((char *) (var->bytes + var->name_ofs)) + 1);
}

var_t *bmem_var_find(const char *name)
{
    var_t *var = bmem_var_first();
    while (var)
    {
        if (strcmp((char *) (var->bytes + var->name_ofs), name) == 0)
            return var;
        var = bmem_var_next(var);
    }
    return 0;
}

static var_t *bmem_var_first()
{
    if (bmem->vars_start == bmem->vars_end)
        return 0;
    return (var_t*) bmem->vars_start;
}

static var_t *bmem_var_next(var_t *var)
{
    int size = bmem_var_size(var);
    var_t *next = (var_t *) ((uint8_t *) var + size);
    if ((uint8_t *) next >= bmem->vars_end)
        return 0;
    return next;
}

static void bmem_var_unset(var_t *var)
{
    int size = bmem_var_size(var);
    memmove(bmem->vars_start + size, bmem->vars_start, (uint8_t *) var - bmem->vars_start);
    bmem->vars_start += size;
}

static void bmem_vars_clear()
{
    bmem->vars_start = bmem->vars_end;
}

static var_t *bmem_var_string_set(const char *name, char *value)
{
    // Remove the variable if it already exists
    var_t *var = bmem_var_find(name);
    if (var != 0)
        bmem_var_unset(var);

    // Copy the name
    // FIXME: create a temporary buffer in the bmem_t structure or in global
    // memory
    char tmp[32];
    strncpy(tmp, name, sizeof(tmp) - 1);
    tmp[sizeof(tmp) - 1] = 0;

    // Create the variable and copy the value
    var = bmem_var_new(tmp, TOKEN_VARIABLE_STRING, bmem_strlen(value), 0);
    if (var == 0)
        goto finalize;
    strcpy(var->string, value ? value : "");

finalize:
    return var;
}

static var_t *bmem_var_number_set(const char *name, float value)
{
    var_t *var = bmem_var_find(name);
    if (var == 0)
    {
        var = bmem_var_new(name, TOKEN_VARIABLE_NUMBER, 0, 0);
    }

    if (var == 0)
        return 0;

    var->numbers[0] = value;
    return var;
}

static int bmem_prog_cmp(void *_prog1, void *_prog2)
{
    prog_t *prog1 = (prog_t *)_prog1;
    prog_t *prog2 = (prog_t *)_prog2;
    return prog1->line_no - prog2->line_no;
}

static inline void bmem_invalidate_prog_list()
{
    prog_list.root = 0;
}

void bmem_prog_new()
{
    bmem_vars_clear();
    while (prog_tree.root)
    {
        bmem_prog_line_free((prog_t *)DS_OBJECT_OF(&prog_tree, prog_tree.root));
    }
}

static void bmem_prog_line_free(prog_t *prog)
{
    if (prog->line_no != 0)
    {
        bmem_invalidate_prog_list();
        ds_btree_remove_object(&prog_tree, prog);
    }
    free(prog->line);
    free(prog);
}

static prog_t *bmem_prog_line_new(uint16_t line_no, uint8_t *line, uint16_t len)
{

    if (len == 0 && line_no == 0)
        return 0;

    bmem_invalidate_prog_list();

    prog_t search = {
        .line_no = line_no,
    };

    prog_t *prog = ds_btree_find(&prog_tree, &search);
    if (prog != 0)
    {
        bmem_prog_line_free(prog);
    }

    if (len == 0)
        return 0;

    prog = (prog_t *)malloc(sizeof(prog_t));
    if (prog == 0)
        return 0;

    prog->line = (uint8_t *)malloc(len + 1);
    if (prog->line == 0)
    {
        free(prog);
        return 0;
    }

    memcpy(prog->line, line, len);
    prog->line[len] = 0;
    prog->len = len;
    prog->line_no = line_no;

    if (line_no > 0)
    {
        ds_btree_insert(&prog_tree, prog);
    }

    return prog;
}

static void bmem_prog_node_push(ds_btree_item_t *node)
{
    if (node)
    {
        bmem_prog_node_push(node->right);
        ds_lifo_push(&prog_list, DS_OBJECT_OF(&prog_tree, node));
        bmem_prog_node_push(node->left);
    }
}

static prog_t *bmem_prog_first_line()
{
    if (prog_list.root == 0)
    {
        bmem_prog_node_push(prog_tree.root);
    }

    if (prog_list.root == 0)
        return 0;

    return (prog_t *)(DS_OBJECT_OF(&prog_list, prog_list.root));
}

static prog_t *bmem_prog_next_line(prog_t *prog)
{
    if (!prog)
        return 0;

    if (!(prog->list.next))
        return 0;

    return (prog_t *) (DS_OBJECT_OF(&prog_list, prog->list.next));
}

static prog_t *bmem_prog_get_line(uint16_t line_no)
{
    prog_t search = {
        .line_no = line_no,
    };

    if (prog_list.root == 0)
    {
        bmem_prog_node_push(prog_tree.root);
    }

    return ds_btree_find(&prog_tree, &search);
}

static void bmem_init(uint8_t *mem, uint16_t size)
{
    // Init memory
    bmem = (bmem_t *) mem;
    memset(bmem, 0, size);
    bmem->prog_start = (uint8_t *) bmem + sizeof(bmem_t);
    bmem->prog_end = bmem->prog_start;
    bmem->vars_end = (uint8_t *) bmem + size;
    bmem_vars_clear();

    ds_btree_init(&prog_tree, offsetof(prog_t, tree), bmem_prog_cmp);
    ds_lifo_init(&prog_list, offsetof(prog_t, list));
}

#include <assert.h>

void bmem_test()
{
    // Init memory
    bmem_init(malloc(BASTOS_MEMORY_SIZE), BASTOS_MEMORY_SIZE);

    // print free memory
    printf("Free memory: %zd bytes\n", bmem->vars_start - bmem->prog_end);
    // print system variables size
    printf("System variables size: %zd bytes\n", bmem->prog_start - (uint8_t *) bmem);

    // Example 1: simple number variable
    printf("Example 1: simple number variable\n");
    var_t *var = bmem_var_number_set("toto", 37.2f);
    printf("toto = %g\n", var->numbers[0]);
    assert(var->numbers[0] == 37.2f);

    // Example 2: simple string variable
    printf("Example 2: simple string variable\n");
    var = bmem_var_string_set("titi", "Hello world!");
    printf("titi = %s\n", var->string);
    assert(strcmp(var->string, "Hello world!") == 0);

    // Example 3: 1D array of numbers
    printf("Example 3: 1D array of numbers\n");
    uint32_t dims[1] = { 3 };
    var = bmem_var_new("tata", TOKEN_ARRAY_NUMBER, 1, dims);
    // Offset of the 1st element in the numbers (32 bits) array
    int offset = var->dim_count;
    for (int i = 0; i < dims[0]; i++)
    {
        var->numbers[i + offset] = (i + 1) * 13;
    }
    for (int i = 0; i < dims[0]; i++)
    {
        printf("tata[%d] = %g\n", i, var->numbers[i + offset]);
        assert(var->numbers[i + offset] == (i + 1) * 13);
    }

    // Example 4: 6 strings of 5 chars
    printf("Example 4: 6 strings of 5 chars\n");
    uint32_t dims2[2] = { 6, 5 + 1 };
    var = bmem_var_new("tutu", TOKEN_ARRAY_STRING, 2, dims2);
    // Offset of the 1st element in the bytes array
    offset = var->dim_count * sizeof(uint32_t);
    char *src[] = { "zero", "one", "two", "three", "four", "five" };
    for (int i = 0; i < dims2[0]; i++)
    {
        char* dst = (char *) &var->bytes[i * dims2[1] + offset];
        strncpy(dst, src[i], dims2[1]);
    }
    for (int i = 0; i < dims2[0]; i++)
    {
        char* dst = (char *) &var->bytes[i * dims2[1] + offset];
        printf("tutu[%d] = %s\n", i, dst);
        assert(strcmp(dst, src[i]) == 0);
    }

    // Example 5: 2D array of numbers
    printf("Example 5: 2D array of numbers\n");
    uint32_t dims3[2] = { 3, 4 };
    var = bmem_var_new("tata2D", TOKEN_ARRAY_NUMBER, 2, dims3);
    // Offset of the 1st element in the numbers (32 bits) array
    offset = var->dim_count;
    for (int i = 0; i < dims3[0]; i++)
    {
        for (int j = 0; j < dims3[1]; j++)
        {
            var->numbers[i * dims3[1] + j + offset] = (i + 1) * (j + 1) * 13;
        }
    }
    for (int i = 0; i < dims3[0]; i++)
    {
        for (int j = 0; j < dims3[1]; j++)
        {
            printf("tata2D[%d][%d] = %g\n", i, j, var->numbers[i * dims3[1] + j + offset]);
            assert(var->numbers[i * dims3[1] + j + offset] == (i + 1) * (j + 1) * 13);
        }
    }

    // Iterate over all variables
    printf("Iterate over all variables\n");
    var_t *v = bmem_var_first();
    while (v)
    {
        // print name and type of variable
        printf("'%s' (%x)\n", name_of_var(v), v->token);
        // check type vs name
        if (strcmp(name_of_var(v), "toto") == 0)
        {
            assert(v->token == TOKEN_VARIABLE_NUMBER);
        }
        else if (strcmp(name_of_var(v), "titi") == 0)
        {
            assert(v->token == TOKEN_VARIABLE_STRING);
        }
        else if (strcmp(name_of_var(v), "tata") == 0)
        {
            assert(v->token == TOKEN_ARRAY_NUMBER);
        }
        else if (strcmp(name_of_var(v), "tutu") == 0)
        {
            assert(v->token == TOKEN_ARRAY_STRING);
        }
        else
        {
            printf("Error: unknown variable '%s'\n", name_of_var(v));
        }
        v = bmem_var_next(v);
    }

    // Remove "tata" variable
    printf("Remove tata variable\n");
    var = bmem_var_find("tata");
    bmem_var_unset(var);
    // Test if "tata" is still there
    var = bmem_var_find("tata");
    if (var)
    {
        printf("Error: tata is still there\n");
    }
    else
    {
        printf("tata is gone\n");
    }
    assert(var == 0);

    // Iterate over all variables and count them
    printf("Iterate over all variables and count them\n");
    int count = 0;
    v = bmem_var_first();
    while (v)
    {
        printf("'%s' (%x)\n", name_of_var(v), v->token);
        count++;
        v = bmem_var_next(v);
    }
    printf("There are %d variables\n", count);
    assert(count == 4);
}
